// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "v1.proto" (syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "./google/protobuf/timestamp";
/**
 * @generated from protobuf message RecordingSample
 */
export interface RecordingSample {
    /**
     * @generated from protobuf field: google.protobuf.Timestamp unix_time = 1
     */
    unixTime?: Timestamp;
    /**
     * @generated from protobuf field: uint32 frame_number = 2
     */
    frameNumber: number;
    /**
     * @generated from protobuf field: bool bluetooth_connected = 3
     */
    bluetoothConnected: boolean;
    /**
     * @generated from protobuf field: int32 fan_current = 4
     */
    fanCurrent: number;
    /**
     * @generated from protobuf field: int32 pump_current = 5
     */
    pumpCurrent: number;
    /**
     * @generated from protobuf field: int32 vcu_humidity = 6
     */
    vcuHumidity: number;
    /**
     * @generated from protobuf field: int32 vcu_temperature = 7
     */
    vcuTemperature: number;
    /**
     * @generated from protobuf field: int32 throttle_id_fb = 8
     */
    throttleIdFb: number;
    /**
     * @generated from protobuf field: int32 throttle_iq_fb = 9
     */
    throttleIqFb: number;
    /**
     * @generated from protobuf field: int32 throttle_position = 10
     */
    throttlePosition: number;
    /**
     * @generated from protobuf field: int32 map = 11
     */
    map: number;
    /**
     * @generated from protobuf field: int32 speed_kmh = 12
     */
    speedKmh: number;
    /**
     * @generated from protobuf field: int32 motor_rpm = 13
     */
    motorRpm: number;
    /**
     * @generated from protobuf field: int32 odometer = 14
     */
    odometer: number;
    /**
     * @generated from protobuf field: int32 inverter_dc_bus = 15
     */
    inverterDcBus: number;
    /**
     * @generated from protobuf field: int32 inverter_iq_ref = 16
     */
    inverterIqRef: number;
    /**
     * @generated from protobuf field: int32 inverter_id_ref = 17
     */
    inverterIdRef: number;
    /**
     * @generated from protobuf field: int32 inverter_iq = 18
     */
    inverterIq: number;
    /**
     * @generated from protobuf field: int32 inverter_id = 19
     */
    inverterId: number;
    /**
     * @generated from protobuf field: int32 inverter_vq = 20
     */
    inverterVq: number;
    /**
     * @generated from protobuf field: int32 inverter_vd = 21
     */
    inverterVd: number;
    /**
     * @generated from protobuf field: int32 mcu_temp_logic = 22
     */
    mcuTempLogic: number;
    /**
     * @generated from protobuf field: int32 mcu_temp_gate = 23
     */
    mcuTempGate: number;
    /**
     * @generated from protobuf field: int32 ntc1 = 24
     */
    ntc1: number;
    /**
     * @generated from protobuf field: int32 ntc2 = 25
     */
    ntc2: number;
    /**
     * @generated from protobuf field: int32 ntc3 = 26
     */
    ntc3: number;
    /**
     * @generated from protobuf field: int32 inverter_pcb_temp = 27
     */
    inverterPcbTemp: number;
    /**
     * @generated from protobuf field: int32 inverter_pcb_humidity = 28
     */
    inverterPcbHumidity: number;
    /**
     * @generated from protobuf field: int32 faults = 29
     */
    faults: number;
    /**
     * @generated from protobuf field: int32 status = 30
     */
    status: number;
    /**
     * @generated from protobuf field: int32 inverter_humidity = 31
     */
    inverterHumidity: number;
    /**
     * @generated from protobuf field: int32 misc_bits = 32
     */
    miscBits: number;
    /**
     * @generated from protobuf field: int32 indicator_bits = 33
     */
    indicatorBits: number;
    /**
     * @generated from protobuf field: int32 alert_bits = 34
     */
    alertBits: number;
    /**
     * @generated from protobuf field: int32 fault_bits = 35
     */
    faultBits: number;
    /**
     * @generated from protobuf field: int32 info_bits = 36
     */
    infoBits: number;
    /**
     * @generated from protobuf field: int32 battery_dc_bus = 37
     */
    batteryDcBus: number;
    /**
     * @generated from protobuf field: int32 battery_soc = 38
     */
    batterySoc: number;
    /**
     * @generated from protobuf field: int32 battery_current = 39
     */
    batteryCurrent: number;
    /**
     * @generated from protobuf field: int32 battery_v_min = 40
     */
    batteryVMin: number;
    /**
     * @generated from protobuf field: int32 battery_v_max = 41
     */
    batteryVMax: number;
    /**
     * @generated from protobuf field: int32 battery_v_avg = 42
     */
    batteryVAvg: number;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp gps_timestamp = 43
     */
    gpsTimestamp?: Timestamp;
    /**
     * @generated from protobuf field: float gps_speed = 44
     */
    gpsSpeed: number;
    /**
     * @generated from protobuf field: int32 gps_heading = 45
     */
    gpsHeading: number;
    /**
     * @generated from protobuf field: int32 gps_altitude = 46
     */
    gpsAltitude: number;
    /**
     * @generated from protobuf field: float gps_accuracy = 47
     */
    gpsAccuracy: number;
    /**
     * @generated from protobuf field: float gps_altitude_accuracy = 48
     */
    gpsAltitudeAccuracy: number;
    /**
     * @generated from protobuf field: double gps_longitude = 49
     */
    gpsLongitude: number;
    /**
     * @generated from protobuf field: double gps_latitude = 50
     */
    gpsLatitude: number;
    /**
     * @generated from protobuf field: TemperatureSensorData igbt_sensor = 51
     */
    igbtSensor?: TemperatureSensorData;
    /**
     * @generated from protobuf field: TemperatureSensorData motor_sensor = 52
     */
    motorSensor?: TemperatureSensorData;
    /**
     * @generated from protobuf field: IMUData imu_data = 53
     */
    imuData?: IMUData;
    /**
     * @generated from protobuf field: repeated int32 battery_temperatures = 54
     */
    batteryTemperatures: number[];
    /**
     * @generated from protobuf field: repeated int32 battery_cell_voltages = 55
     */
    batteryCellVoltages: number[];
}
/**
 * @generated from protobuf message IMUData
 */
export interface IMUData {
    /**
     * @generated from protobuf field: int32 accel_x = 1
     */
    accelX: number;
    /**
     * @generated from protobuf field: int32 accel_y = 2
     */
    accelY: number;
    /**
     * @generated from protobuf field: int32 accel_z = 3
     */
    accelZ: number;
    /**
     * @generated from protobuf field: int32 gyro_x = 4
     */
    gyroX: number;
    /**
     * @generated from protobuf field: int32 gyro_y = 5
     */
    gyroY: number;
    /**
     * @generated from protobuf field: int32 gyro_z = 6
     */
    gyroZ: number;
}
/**
 * @generated from protobuf message TemperatureSensorData
 */
export interface TemperatureSensorData {
    /**
     * @generated from protobuf field: int32 sensor1 = 1
     */
    sensor1: number;
    /**
     * @generated from protobuf field: int32 sensor2 = 2
     */
    sensor2: number;
    /**
     * @generated from protobuf field: int32 sensor3 = 3
     */
    sensor3: number;
    /**
     * @generated from protobuf field: bool valid = 4
     */
    valid: boolean;
    /**
     * @generated from protobuf field: bool used = 5
     */
    used: boolean;
}
// @generated message type with reflection information, may provide speed optimized methods
class RecordingSample$Type extends MessageType<RecordingSample> {
    constructor() {
        super("RecordingSample", [
            { no: 1, name: "unix_time", kind: "message", T: () => Timestamp },
            { no: 2, name: "frame_number", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "bluetooth_connected", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "fan_current", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "pump_current", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "vcu_humidity", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "vcu_temperature", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "throttle_id_fb", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "throttle_iq_fb", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "throttle_position", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "map", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "speed_kmh", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "motor_rpm", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "odometer", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "inverter_dc_bus", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 16, name: "inverter_iq_ref", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 17, name: "inverter_id_ref", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 18, name: "inverter_iq", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 19, name: "inverter_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 20, name: "inverter_vq", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 21, name: "inverter_vd", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 22, name: "mcu_temp_logic", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 23, name: "mcu_temp_gate", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 24, name: "ntc1", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 25, name: "ntc2", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 26, name: "ntc3", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 27, name: "inverter_pcb_temp", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 28, name: "inverter_pcb_humidity", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 29, name: "faults", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 30, name: "status", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 31, name: "inverter_humidity", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 32, name: "misc_bits", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 33, name: "indicator_bits", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 34, name: "alert_bits", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 35, name: "fault_bits", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 36, name: "info_bits", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 37, name: "battery_dc_bus", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 38, name: "battery_soc", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 39, name: "battery_current", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 40, name: "battery_v_min", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 41, name: "battery_v_max", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 42, name: "battery_v_avg", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 43, name: "gps_timestamp", kind: "message", T: () => Timestamp },
            { no: 44, name: "gps_speed", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 45, name: "gps_heading", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 46, name: "gps_altitude", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 47, name: "gps_accuracy", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 48, name: "gps_altitude_accuracy", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 49, name: "gps_longitude", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 50, name: "gps_latitude", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 51, name: "igbt_sensor", kind: "message", T: () => TemperatureSensorData },
            { no: 52, name: "motor_sensor", kind: "message", T: () => TemperatureSensorData },
            { no: 53, name: "imu_data", kind: "message", T: () => IMUData },
            { no: 54, name: "battery_temperatures", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 55, name: "battery_cell_voltages", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<RecordingSample>): RecordingSample {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.frameNumber = 0;
        message.bluetoothConnected = false;
        message.fanCurrent = 0;
        message.pumpCurrent = 0;
        message.vcuHumidity = 0;
        message.vcuTemperature = 0;
        message.throttleIdFb = 0;
        message.throttleIqFb = 0;
        message.throttlePosition = 0;
        message.map = 0;
        message.speedKmh = 0;
        message.motorRpm = 0;
        message.odometer = 0;
        message.inverterDcBus = 0;
        message.inverterIqRef = 0;
        message.inverterIdRef = 0;
        message.inverterIq = 0;
        message.inverterId = 0;
        message.inverterVq = 0;
        message.inverterVd = 0;
        message.mcuTempLogic = 0;
        message.mcuTempGate = 0;
        message.ntc1 = 0;
        message.ntc2 = 0;
        message.ntc3 = 0;
        message.inverterPcbTemp = 0;
        message.inverterPcbHumidity = 0;
        message.faults = 0;
        message.status = 0;
        message.inverterHumidity = 0;
        message.miscBits = 0;
        message.indicatorBits = 0;
        message.alertBits = 0;
        message.faultBits = 0;
        message.infoBits = 0;
        message.batteryDcBus = 0;
        message.batterySoc = 0;
        message.batteryCurrent = 0;
        message.batteryVMin = 0;
        message.batteryVMax = 0;
        message.batteryVAvg = 0;
        message.gpsSpeed = 0;
        message.gpsHeading = 0;
        message.gpsAltitude = 0;
        message.gpsAccuracy = 0;
        message.gpsAltitudeAccuracy = 0;
        message.gpsLongitude = 0;
        message.gpsLatitude = 0;
        message.batteryTemperatures = [];
        message.batteryCellVoltages = [];
        if (value !== undefined)
            reflectionMergePartial<RecordingSample>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecordingSample): RecordingSample {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp unix_time */ 1:
                    message.unixTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.unixTime);
                    break;
                case /* uint32 frame_number */ 2:
                    message.frameNumber = reader.uint32();
                    break;
                case /* bool bluetooth_connected */ 3:
                    message.bluetoothConnected = reader.bool();
                    break;
                case /* int32 fan_current */ 4:
                    message.fanCurrent = reader.int32();
                    break;
                case /* int32 pump_current */ 5:
                    message.pumpCurrent = reader.int32();
                    break;
                case /* int32 vcu_humidity */ 6:
                    message.vcuHumidity = reader.int32();
                    break;
                case /* int32 vcu_temperature */ 7:
                    message.vcuTemperature = reader.int32();
                    break;
                case /* int32 throttle_id_fb */ 8:
                    message.throttleIdFb = reader.int32();
                    break;
                case /* int32 throttle_iq_fb */ 9:
                    message.throttleIqFb = reader.int32();
                    break;
                case /* int32 throttle_position */ 10:
                    message.throttlePosition = reader.int32();
                    break;
                case /* int32 map */ 11:
                    message.map = reader.int32();
                    break;
                case /* int32 speed_kmh */ 12:
                    message.speedKmh = reader.int32();
                    break;
                case /* int32 motor_rpm */ 13:
                    message.motorRpm = reader.int32();
                    break;
                case /* int32 odometer */ 14:
                    message.odometer = reader.int32();
                    break;
                case /* int32 inverter_dc_bus */ 15:
                    message.inverterDcBus = reader.int32();
                    break;
                case /* int32 inverter_iq_ref */ 16:
                    message.inverterIqRef = reader.int32();
                    break;
                case /* int32 inverter_id_ref */ 17:
                    message.inverterIdRef = reader.int32();
                    break;
                case /* int32 inverter_iq */ 18:
                    message.inverterIq = reader.int32();
                    break;
                case /* int32 inverter_id */ 19:
                    message.inverterId = reader.int32();
                    break;
                case /* int32 inverter_vq */ 20:
                    message.inverterVq = reader.int32();
                    break;
                case /* int32 inverter_vd */ 21:
                    message.inverterVd = reader.int32();
                    break;
                case /* int32 mcu_temp_logic */ 22:
                    message.mcuTempLogic = reader.int32();
                    break;
                case /* int32 mcu_temp_gate */ 23:
                    message.mcuTempGate = reader.int32();
                    break;
                case /* int32 ntc1 */ 24:
                    message.ntc1 = reader.int32();
                    break;
                case /* int32 ntc2 */ 25:
                    message.ntc2 = reader.int32();
                    break;
                case /* int32 ntc3 */ 26:
                    message.ntc3 = reader.int32();
                    break;
                case /* int32 inverter_pcb_temp */ 27:
                    message.inverterPcbTemp = reader.int32();
                    break;
                case /* int32 inverter_pcb_humidity */ 28:
                    message.inverterPcbHumidity = reader.int32();
                    break;
                case /* int32 faults */ 29:
                    message.faults = reader.int32();
                    break;
                case /* int32 status */ 30:
                    message.status = reader.int32();
                    break;
                case /* int32 inverter_humidity */ 31:
                    message.inverterHumidity = reader.int32();
                    break;
                case /* int32 misc_bits */ 32:
                    message.miscBits = reader.int32();
                    break;
                case /* int32 indicator_bits */ 33:
                    message.indicatorBits = reader.int32();
                    break;
                case /* int32 alert_bits */ 34:
                    message.alertBits = reader.int32();
                    break;
                case /* int32 fault_bits */ 35:
                    message.faultBits = reader.int32();
                    break;
                case /* int32 info_bits */ 36:
                    message.infoBits = reader.int32();
                    break;
                case /* int32 battery_dc_bus */ 37:
                    message.batteryDcBus = reader.int32();
                    break;
                case /* int32 battery_soc */ 38:
                    message.batterySoc = reader.int32();
                    break;
                case /* int32 battery_current */ 39:
                    message.batteryCurrent = reader.int32();
                    break;
                case /* int32 battery_v_min */ 40:
                    message.batteryVMin = reader.int32();
                    break;
                case /* int32 battery_v_max */ 41:
                    message.batteryVMax = reader.int32();
                    break;
                case /* int32 battery_v_avg */ 42:
                    message.batteryVAvg = reader.int32();
                    break;
                case /* google.protobuf.Timestamp gps_timestamp */ 43:
                    message.gpsTimestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.gpsTimestamp);
                    break;
                case /* float gps_speed */ 44:
                    message.gpsSpeed = reader.float();
                    break;
                case /* int32 gps_heading */ 45:
                    message.gpsHeading = reader.int32();
                    break;
                case /* int32 gps_altitude */ 46:
                    message.gpsAltitude = reader.int32();
                    break;
                case /* float gps_accuracy */ 47:
                    message.gpsAccuracy = reader.float();
                    break;
                case /* float gps_altitude_accuracy */ 48:
                    message.gpsAltitudeAccuracy = reader.float();
                    break;
                case /* double gps_longitude */ 49:
                    message.gpsLongitude = reader.double();
                    break;
                case /* double gps_latitude */ 50:
                    message.gpsLatitude = reader.double();
                    break;
                case /* TemperatureSensorData igbt_sensor */ 51:
                    message.igbtSensor = TemperatureSensorData.internalBinaryRead(reader, reader.uint32(), options, message.igbtSensor);
                    break;
                case /* TemperatureSensorData motor_sensor */ 52:
                    message.motorSensor = TemperatureSensorData.internalBinaryRead(reader, reader.uint32(), options, message.motorSensor);
                    break;
                case /* IMUData imu_data */ 53:
                    message.imuData = IMUData.internalBinaryRead(reader, reader.uint32(), options, message.imuData);
                    break;
                case /* repeated int32 battery_temperatures */ 54:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.batteryTemperatures.push(reader.int32());
                    else
                        message.batteryTemperatures.push(reader.int32());
                    break;
                case /* repeated int32 battery_cell_voltages */ 55:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.batteryCellVoltages.push(reader.int32());
                    else
                        message.batteryCellVoltages.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecordingSample, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp unix_time = 1; */
        if (message.unixTime)
            Timestamp.internalBinaryWrite(message.unixTime, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 frame_number = 2; */
        if (message.frameNumber !== 0)
            writer.tag(2, WireType.Varint).uint32(message.frameNumber);
        /* bool bluetooth_connected = 3; */
        if (message.bluetoothConnected !== false)
            writer.tag(3, WireType.Varint).bool(message.bluetoothConnected);
        /* int32 fan_current = 4; */
        if (message.fanCurrent !== 0)
            writer.tag(4, WireType.Varint).int32(message.fanCurrent);
        /* int32 pump_current = 5; */
        if (message.pumpCurrent !== 0)
            writer.tag(5, WireType.Varint).int32(message.pumpCurrent);
        /* int32 vcu_humidity = 6; */
        if (message.vcuHumidity !== 0)
            writer.tag(6, WireType.Varint).int32(message.vcuHumidity);
        /* int32 vcu_temperature = 7; */
        if (message.vcuTemperature !== 0)
            writer.tag(7, WireType.Varint).int32(message.vcuTemperature);
        /* int32 throttle_id_fb = 8; */
        if (message.throttleIdFb !== 0)
            writer.tag(8, WireType.Varint).int32(message.throttleIdFb);
        /* int32 throttle_iq_fb = 9; */
        if (message.throttleIqFb !== 0)
            writer.tag(9, WireType.Varint).int32(message.throttleIqFb);
        /* int32 throttle_position = 10; */
        if (message.throttlePosition !== 0)
            writer.tag(10, WireType.Varint).int32(message.throttlePosition);
        /* int32 map = 11; */
        if (message.map !== 0)
            writer.tag(11, WireType.Varint).int32(message.map);
        /* int32 speed_kmh = 12; */
        if (message.speedKmh !== 0)
            writer.tag(12, WireType.Varint).int32(message.speedKmh);
        /* int32 motor_rpm = 13; */
        if (message.motorRpm !== 0)
            writer.tag(13, WireType.Varint).int32(message.motorRpm);
        /* int32 odometer = 14; */
        if (message.odometer !== 0)
            writer.tag(14, WireType.Varint).int32(message.odometer);
        /* int32 inverter_dc_bus = 15; */
        if (message.inverterDcBus !== 0)
            writer.tag(15, WireType.Varint).int32(message.inverterDcBus);
        /* int32 inverter_iq_ref = 16; */
        if (message.inverterIqRef !== 0)
            writer.tag(16, WireType.Varint).int32(message.inverterIqRef);
        /* int32 inverter_id_ref = 17; */
        if (message.inverterIdRef !== 0)
            writer.tag(17, WireType.Varint).int32(message.inverterIdRef);
        /* int32 inverter_iq = 18; */
        if (message.inverterIq !== 0)
            writer.tag(18, WireType.Varint).int32(message.inverterIq);
        /* int32 inverter_id = 19; */
        if (message.inverterId !== 0)
            writer.tag(19, WireType.Varint).int32(message.inverterId);
        /* int32 inverter_vq = 20; */
        if (message.inverterVq !== 0)
            writer.tag(20, WireType.Varint).int32(message.inverterVq);
        /* int32 inverter_vd = 21; */
        if (message.inverterVd !== 0)
            writer.tag(21, WireType.Varint).int32(message.inverterVd);
        /* int32 mcu_temp_logic = 22; */
        if (message.mcuTempLogic !== 0)
            writer.tag(22, WireType.Varint).int32(message.mcuTempLogic);
        /* int32 mcu_temp_gate = 23; */
        if (message.mcuTempGate !== 0)
            writer.tag(23, WireType.Varint).int32(message.mcuTempGate);
        /* int32 ntc1 = 24; */
        if (message.ntc1 !== 0)
            writer.tag(24, WireType.Varint).int32(message.ntc1);
        /* int32 ntc2 = 25; */
        if (message.ntc2 !== 0)
            writer.tag(25, WireType.Varint).int32(message.ntc2);
        /* int32 ntc3 = 26; */
        if (message.ntc3 !== 0)
            writer.tag(26, WireType.Varint).int32(message.ntc3);
        /* int32 inverter_pcb_temp = 27; */
        if (message.inverterPcbTemp !== 0)
            writer.tag(27, WireType.Varint).int32(message.inverterPcbTemp);
        /* int32 inverter_pcb_humidity = 28; */
        if (message.inverterPcbHumidity !== 0)
            writer.tag(28, WireType.Varint).int32(message.inverterPcbHumidity);
        /* int32 faults = 29; */
        if (message.faults !== 0)
            writer.tag(29, WireType.Varint).int32(message.faults);
        /* int32 status = 30; */
        if (message.status !== 0)
            writer.tag(30, WireType.Varint).int32(message.status);
        /* int32 inverter_humidity = 31; */
        if (message.inverterHumidity !== 0)
            writer.tag(31, WireType.Varint).int32(message.inverterHumidity);
        /* int32 misc_bits = 32; */
        if (message.miscBits !== 0)
            writer.tag(32, WireType.Varint).int32(message.miscBits);
        /* int32 indicator_bits = 33; */
        if (message.indicatorBits !== 0)
            writer.tag(33, WireType.Varint).int32(message.indicatorBits);
        /* int32 alert_bits = 34; */
        if (message.alertBits !== 0)
            writer.tag(34, WireType.Varint).int32(message.alertBits);
        /* int32 fault_bits = 35; */
        if (message.faultBits !== 0)
            writer.tag(35, WireType.Varint).int32(message.faultBits);
        /* int32 info_bits = 36; */
        if (message.infoBits !== 0)
            writer.tag(36, WireType.Varint).int32(message.infoBits);
        /* int32 battery_dc_bus = 37; */
        if (message.batteryDcBus !== 0)
            writer.tag(37, WireType.Varint).int32(message.batteryDcBus);
        /* int32 battery_soc = 38; */
        if (message.batterySoc !== 0)
            writer.tag(38, WireType.Varint).int32(message.batterySoc);
        /* int32 battery_current = 39; */
        if (message.batteryCurrent !== 0)
            writer.tag(39, WireType.Varint).int32(message.batteryCurrent);
        /* int32 battery_v_min = 40; */
        if (message.batteryVMin !== 0)
            writer.tag(40, WireType.Varint).int32(message.batteryVMin);
        /* int32 battery_v_max = 41; */
        if (message.batteryVMax !== 0)
            writer.tag(41, WireType.Varint).int32(message.batteryVMax);
        /* int32 battery_v_avg = 42; */
        if (message.batteryVAvg !== 0)
            writer.tag(42, WireType.Varint).int32(message.batteryVAvg);
        /* google.protobuf.Timestamp gps_timestamp = 43; */
        if (message.gpsTimestamp)
            Timestamp.internalBinaryWrite(message.gpsTimestamp, writer.tag(43, WireType.LengthDelimited).fork(), options).join();
        /* float gps_speed = 44; */
        if (message.gpsSpeed !== 0)
            writer.tag(44, WireType.Bit32).float(message.gpsSpeed);
        /* int32 gps_heading = 45; */
        if (message.gpsHeading !== 0)
            writer.tag(45, WireType.Varint).int32(message.gpsHeading);
        /* int32 gps_altitude = 46; */
        if (message.gpsAltitude !== 0)
            writer.tag(46, WireType.Varint).int32(message.gpsAltitude);
        /* float gps_accuracy = 47; */
        if (message.gpsAccuracy !== 0)
            writer.tag(47, WireType.Bit32).float(message.gpsAccuracy);
        /* float gps_altitude_accuracy = 48; */
        if (message.gpsAltitudeAccuracy !== 0)
            writer.tag(48, WireType.Bit32).float(message.gpsAltitudeAccuracy);
        /* double gps_longitude = 49; */
        if (message.gpsLongitude !== 0)
            writer.tag(49, WireType.Bit64).double(message.gpsLongitude);
        /* double gps_latitude = 50; */
        if (message.gpsLatitude !== 0)
            writer.tag(50, WireType.Bit64).double(message.gpsLatitude);
        /* TemperatureSensorData igbt_sensor = 51; */
        if (message.igbtSensor)
            TemperatureSensorData.internalBinaryWrite(message.igbtSensor, writer.tag(51, WireType.LengthDelimited).fork(), options).join();
        /* TemperatureSensorData motor_sensor = 52; */
        if (message.motorSensor)
            TemperatureSensorData.internalBinaryWrite(message.motorSensor, writer.tag(52, WireType.LengthDelimited).fork(), options).join();
        /* IMUData imu_data = 53; */
        if (message.imuData)
            IMUData.internalBinaryWrite(message.imuData, writer.tag(53, WireType.LengthDelimited).fork(), options).join();
        /* repeated int32 battery_temperatures = 54; */
        if (message.batteryTemperatures.length) {
            writer.tag(54, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.batteryTemperatures.length; i++)
                writer.int32(message.batteryTemperatures[i]);
            writer.join();
        }
        /* repeated int32 battery_cell_voltages = 55; */
        if (message.batteryCellVoltages.length) {
            writer.tag(55, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.batteryCellVoltages.length; i++)
                writer.int32(message.batteryCellVoltages[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RecordingSample
 */
export const RecordingSample = new RecordingSample$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IMUData$Type extends MessageType<IMUData> {
    constructor() {
        super("IMUData", [
            { no: 1, name: "accel_x", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "accel_y", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "accel_z", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "gyro_x", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "gyro_y", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "gyro_z", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<IMUData>): IMUData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accelX = 0;
        message.accelY = 0;
        message.accelZ = 0;
        message.gyroX = 0;
        message.gyroY = 0;
        message.gyroZ = 0;
        if (value !== undefined)
            reflectionMergePartial<IMUData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IMUData): IMUData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 accel_x */ 1:
                    message.accelX = reader.int32();
                    break;
                case /* int32 accel_y */ 2:
                    message.accelY = reader.int32();
                    break;
                case /* int32 accel_z */ 3:
                    message.accelZ = reader.int32();
                    break;
                case /* int32 gyro_x */ 4:
                    message.gyroX = reader.int32();
                    break;
                case /* int32 gyro_y */ 5:
                    message.gyroY = reader.int32();
                    break;
                case /* int32 gyro_z */ 6:
                    message.gyroZ = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IMUData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 accel_x = 1; */
        if (message.accelX !== 0)
            writer.tag(1, WireType.Varint).int32(message.accelX);
        /* int32 accel_y = 2; */
        if (message.accelY !== 0)
            writer.tag(2, WireType.Varint).int32(message.accelY);
        /* int32 accel_z = 3; */
        if (message.accelZ !== 0)
            writer.tag(3, WireType.Varint).int32(message.accelZ);
        /* int32 gyro_x = 4; */
        if (message.gyroX !== 0)
            writer.tag(4, WireType.Varint).int32(message.gyroX);
        /* int32 gyro_y = 5; */
        if (message.gyroY !== 0)
            writer.tag(5, WireType.Varint).int32(message.gyroY);
        /* int32 gyro_z = 6; */
        if (message.gyroZ !== 0)
            writer.tag(6, WireType.Varint).int32(message.gyroZ);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message IMUData
 */
export const IMUData = new IMUData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TemperatureSensorData$Type extends MessageType<TemperatureSensorData> {
    constructor() {
        super("TemperatureSensorData", [
            { no: 1, name: "sensor1", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "sensor2", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "sensor3", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "valid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "used", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TemperatureSensorData>): TemperatureSensorData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sensor1 = 0;
        message.sensor2 = 0;
        message.sensor3 = 0;
        message.valid = false;
        message.used = false;
        if (value !== undefined)
            reflectionMergePartial<TemperatureSensorData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TemperatureSensorData): TemperatureSensorData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 sensor1 */ 1:
                    message.sensor1 = reader.int32();
                    break;
                case /* int32 sensor2 */ 2:
                    message.sensor2 = reader.int32();
                    break;
                case /* int32 sensor3 */ 3:
                    message.sensor3 = reader.int32();
                    break;
                case /* bool valid */ 4:
                    message.valid = reader.bool();
                    break;
                case /* bool used */ 5:
                    message.used = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TemperatureSensorData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 sensor1 = 1; */
        if (message.sensor1 !== 0)
            writer.tag(1, WireType.Varint).int32(message.sensor1);
        /* int32 sensor2 = 2; */
        if (message.sensor2 !== 0)
            writer.tag(2, WireType.Varint).int32(message.sensor2);
        /* int32 sensor3 = 3; */
        if (message.sensor3 !== 0)
            writer.tag(3, WireType.Varint).int32(message.sensor3);
        /* bool valid = 4; */
        if (message.valid !== false)
            writer.tag(4, WireType.Varint).bool(message.valid);
        /* bool used = 5; */
        if (message.used !== false)
            writer.tag(5, WireType.Varint).bool(message.used);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TemperatureSensorData
 */
export const TemperatureSensorData = new TemperatureSensorData$Type();
